{"version":3,"file":"js/Background-2.0.min.js","mappings":";;;;;;;;;;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AACA;AACA;AACA;AAEA;AAAA;AAGA;AAAA;AAAA;AAKA;AACA;AACA;AAAA;AAGA;AACA;AACA;AAAA;AAGA;;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AAGA;AAEA;AACA;AAOA;AAEA;AACA;AACA;AAAA;AAGA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAvIA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAFA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAIA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AA0GA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAAA;;AAEA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AAEA;AACA;AAGA;AAIA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAMA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AAGA;AACA;AAGA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAraA;AACA;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA","sources":["webpack://theme/./src/js/components/Background.js","webpack://theme/./node_modules/fastdom/fastdom.js"],"sourcesContent":["import gsap from \"gsap\";\nimport ScrollTrigger from \"gsap/ScrollTrigger\";\nimport tinycolor from \"tinycolor2\";\nimport fastdom from 'fastdom';\n\ngsap.registerPlugin(ScrollTrigger);\n\nexport default class Background {\n    constructor() {\n        this.init();\n    }\n\n    init = () => {\n        this.setDomMap();\n        this.bindEvents();\n    };\n\n    setDomMap = () => {\n        this.window = $(window);\n        this.body = $(\"body\");\n    };\n\n    bindEvents = () => {\n        \"use strict\";\n\n        window.liquidIsElementor =\n            window.liquidIsElementor ||\n            document.body.classList.contains(\"elementor-page\");\n        window.liquidElements = ($) => {\n            window.$liquidWindow = $(window);\n            window.$liquidBody = $(\"body\");\n            window.$liquidSiteWrap = $(\"#wrap\");\n            window.$liquidContents = $(\"#lqd-site-content\");\n            window.$liquidContentsWrap = $(\"#lqd-contents-wrap\");\n            window.$liquidMainHeader = $(\".main-header\");\n            window.$liquidMainFooter = $(\".main-footer\");\n            window.$liquidSectionsWrapper = $liquidContentsWrap;\n\n            window.$liquidSections = liquidIsElementor\n                ? $liquidSectionsWrapper\n                    .find(elementorSectionsSelector)\n                    .add($elementorFooterSections)\n                : $liquidSectionsWrapper.add($liquidMainFooter).find(\".lqd-section\");\n\n            window.liquidBodyBg = window.$liquidBody.css(\"backgroundColor\");\n            window.liquidContentsBg = window.$liquidContents.css(\"backgroundColor\");\n        };\n\n\n        liquidElements(jQuery);\n\n        window.liquidIsMobile = function () {\n            return (\n                /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n                    navigator.userAgent,\n                ) ||\n                (navigator.platform === \"MacIntel\" && navigator.maxTouchPoints > 0) ||\n                navigator.platform === \"iPad\"\n            );\n        };\n\n        window.liquidWindowWidth = function () {\n            return window.innerWidth;\n        };\n\n        class LiquidSectionsDetails {\n            constructor() {\n                this.sections = [];\n            }\n            static getInstance() {\n                if (!this.instance) {\n                    this.instance = new LiquidSectionsDetails();\n                }\n                return this.instance;\n            }\n            static getDetails() {\n                const instance = this.getInstance();\n                return new Promise(async (resolve) => {\n                    if (instance.sections.length < 1) {\n                        instance.sections = [];\n                        const liquidContentsRect = await instance.getElementRect({\n                            element: $liquidContents[0],\n                        });\n                        await Promise.all(instance.init(liquidContentsRect, instance));\n                        const mainContentSections = instance.sections.filter(\n                            (section) => section.isInMainContent,\n                        );\n                        if (mainContentSections.length < 1) {\n                            const DOM = {\n                                element: $liquidContents[0],\n                                $element: $liquidContents,\n                            };\n                            await instance\n                                .createDetailsObj(liquidContentsRect, liquidContentsRect, DOM, true)\n                                .then((detailsObj) => {\n                                    instance.sections.unshift(detailsObj);\n                                });\n                        }\n                        await instance.addLuminosity(instance);\n                    }\n                    resolve(instance.sections);\n                });\n            }\n            init(liquidContentsRect, instance) {\n                const promises = [];\n                $liquidSections.each((i, row) => {\n                    const promise = new Promise((resolve) => {\n                        const DOM = {\n                            element: row,\n                            $element: jQuery(row),\n                            parent: row.parentElement,\n                        };\n                        this.getElementRect(DOM).then((rowRect) => {\n                            this.createDetailsObj(liquidContentsRect, rowRect, DOM, false).then(\n                                (detailsObj) => {\n                                    instance.sections[i] = detailsObj;\n                                    resolve(detailsObj);\n                                },\n                            );\n                        });\n                    });\n                    promises.push(promise);\n                });\n                return promises;\n            }\n            getElementRect(DOM) {\n                return new Promise((resolve) => {\n                    new IntersectionObserver(([entry], observer) => {\n                        fastdom.measure(() => {\n                            observer.disconnect();\n                            resolve(entry.boundingClientRect);\n                        });\n                    }).observe(DOM.element);\n                });\n            }\n            createDetailsObj(liquidContentsRect, rowRect, DOM, isLiquidContentElement) {\n                return new Promise((resolve) => {\n                    fastdom.measure(async () => {\n                        const { scrollY, scrollX } = window;\n                        const styles = getComputedStyle(DOM.element);\n                        const obj = {};\n                        obj.el = DOM.element;\n                        obj.$el = DOM.$element;\n                        obj.rect = {\n                            initialOffset: {\n                                x: rowRect.x + scrollX,\n                                y: rowRect.y + scrollY,\n                            },\n                            width: rowRect.width,\n                            height: rowRect.height,\n                            x: rowRect.x,\n                            y: rowRect.y,\n                        };\n                        obj.backgroundColor = styles.backgroundColor;\n                        if (isLiquidContentElement) {\n                            obj.isMainContentElement = true;\n                            return resolve(obj);\n                        }\n                        const footerParent = DOM.element.closest(\".main-footer\");\n\n                        obj.isInFooter = footerParent != null;\n                        obj.isInMainContent = DOM.element.closest(\"#lqd-site-content\") != null;\n                        obj.isHidden = obj.rect.width < 1 && obj.rect.height < 1;\n                        obj.predefinedLuminosity = null;\n                        obj.parentSection = null;\n                        obj.innerSections = [];\n                        if (obj.el.hasAttribute(\"data-section-luminosity\")) {\n                            obj.predefinedLuminosity = obj.el.getAttribute(\n                                \"data-section-luminosity\",\n                            );\n                        }\n\n                        resolve(obj);\n                    });\n                });\n            }\n\n            getLuminosity(obj, instance) {\n                let { backgroundColor } = obj;\n                if (\n                    obj.isInnerSection &&\n                    obj.parentSection &&\n                    tinycolor(backgroundColor).getAlpha() === 0\n                ) {\n                    backgroundColor = obj.parentSection.backgroundColor;\n                }\n                if (tinycolor(backgroundColor).getAlpha() === 0) {\n                    if (obj.isInFooter) {\n                        backgroundColor = instance.footerBg;\n                    } else {\n                        backgroundColor = window.liquidContentsBg;\n                    }\n                }\n                return tinycolor(backgroundColor).isDark() ? \"dark\" : \"light\";\n            }\n            async addLuminosity(instance) {\n                instance.sections.forEach(async (sec) => {\n                    sec.isBgTransparent = tinycolor(sec.backgroundColor).getAlpha() === 0;\n                    sec.luminosity = sec.predefinedLuminosity\n                        ? sec.predefinedLuminosity\n                        : instance.getLuminosity(sec, instance);\n                    await fastdomPromised.mutate(() => {\n                        sec.el.setAttribute(\"data-section-luminosity\", sec.luminosity);\n                    });\n                });\n            }\n        }\n\n        (function ($) {\n            \"use strict\";\n\n            const pluginName = \"liquidBgColor\";\n            let defaults = {\n                getBgFromSelector: \"backgroundColor\",\n                setBgTo: \"self\",\n                manipulateColor: null,\n                changeBorderColor: false,\n                interactWithHeader: false,\n                makeGradient: false,\n            };\n            class Plugin {\n                constructor(element, options) {\n                    this._defaults = defaults;\n                    this._name = pluginName;\n                    this.options = {\n                        ...defaults,\n                        ...options,\n                    };\n                    this.element = element;\n                    this.$element = $(element);\n                    this.setBgToEls =\n                        this.options.setBgTo === \"self\"\n                            ? [this.element]\n                            : $(this.options.setBgTo, this.element).get();\n                    this.bgEl = false;\n                    this.rowsRect = [];\n                    this.colors = [];\n                    this.direction = 0;\n                    this.$element.is($liquidContents) && this._addBgElement();\n                    this.liquidBgColorInitPromise = new Promise((resolve) => {\n                        this.$element.on(\"lqd-bg-color-init\", resolve.bind(this, this));\n                    });\n                    // LiquidSectionsDetails.getDetails().then((sections) => {\n                    // \t$(sections).imagesLoaded(this._init(sections));\n                    // });\n                    LiquidSectionsDetails.getDetails().then((sections) => {\n                        if ($.fn.imagesLoaded) {\n                            // Only call imagesLoaded if it exists\n                            $(sections).imagesLoaded(this._init(sections));\n                        } else {\n                            // console.warn(\"imagesLoaded function is missing. Initializing without imagesLoaded.\");\n                            // Fall back to calling _init directly if imagesLoaded is not available\n                            this._init(sections);\n                        }\n                    });\n                }\n\n                _init(liquidSections) {\n                    const sections = liquidSections\n                        .filter((sec) => !sec.isHidden && !sec.isInFooter)\n                        .filter((sec) => !sec.isInnerSection);\n\n                    // console.log(sections);\n\n                    sections.forEach(async (sec, i) => {\n                        await this._getColors(sec);\n                        Promise.all(this._getRects(sec, i)).then(() => {\n                            this._setupIO(sec, i);\n\n                            if (this.bgEl) {\n                                this.element.classList.add(\"transparent-bg\");\n                                sec.el.classList.add(\"transparent-bg\");\n\n                                if (sec.isInnerSection && sec.parentSection) {\n                                    sec.parentSection.el.classList.add(\"transparent-bg\");\n                                }\n                            }\n                        });\n                    });\n\n                    const event = new Event(\"lqd-bg-color-init\");\n                    this.element.dispatchEvent(event);\n                }\n\n                _addBgElement() {\n                    if (this.bgEl) return;\n\n                    const overflowClassname = liquidIsMobile() ? \"overflow-hidden\" : \"\";\n                    const posClassname = liquidIsMobile()\n                        ? \"pos-fix fixed\"\n                        : \"pos-sticky sticky\";\n                    const heightClassname = liquidIsMobile()\n                        ? \"h-100 h-full\"\n                        : \"h-vh-100 h-100vh\";\n\n                    this.bgEl = document.createElement(\"div\");\n                    this.bgEl.className = `lqd-liquid-bg-el-wrap lqd-overlay pointer-events-none z-index--1 ${overflowClassname}`;\n\n                    const bgElement = document.createElement(\"div\");\n                    bgElement.className = `lqd-liquid-bg-el ${posClassname} pos-tl w-100 top-0 left-0 w-full ${heightClassname} pointer-events-none`;\n\n                    this.bgEl.appendChild(bgElement);\n                    document.body.appendChild(this.bgEl);\n\n                    // console.log(this.bgEl);\n                }\n\n                _getColors(lqdSection) {\n                    return fastdomPromised.measure(() => {\n                        const { getBgFromSelector, manipulateColor } = this.options;\n                        const obj = {};\n                        let color = lqdSection[getBgFromSelector]\n                            .replace(/, /g, \",\")\n                            .split(\" \")[0];\n                        let dataLuminosityAttr = lqdSection.$el.attr(\"data-section-luminosity\");\n\n                        if (lqdSection.isBgTransparent) {\n                            color = $liquidContents.css(\"backgroundColor\");\n                        }\n                        if (manipulateColor && manipulateColor.length > 0) {\n                            for (let i = 0; i < manipulateColor.length; i++) {\n                                color = tinycolor(color)\n                                [Object.keys(manipulateColor[i])[0]](\n                                    Object.values(manipulateColor[i])[0],\n                                )\n                                    .toString();\n                            }\n                        }\n                        obj.color = color;\n                        obj.luminosity =\n                            dataLuminosityAttr != null && !manipulateColor\n                                ? dataLuminosityAttr\n                                : tinycolor(color).getLuminance() <= 0.4\n                                    ? \"dark\"\n                                    : \"light\";\n                        this.colors.push(obj);\n                    });\n                }\n\n                _getRects(lqdSection, loopIndex) {\n                    const promises = [];\n\n                    const rowPromise = new Promise((resolve) => {\n                        new IntersectionObserver(([entry], observer) => {\n                            observer.disconnect();\n                            this.rowsRect[loopIndex] = entry.boundingClientRect;\n                            resolve();\n                        }).observe(lqdSection.el);\n                    });\n                    promises.push(rowPromise);\n                    return promises;\n                }\n                _setupIO(lqdSection, loopIndex) {\n                    const timeline = gsap.timeline();\n                    const start =\n                        loopIndex === 0\n                            ? \"top bottom\"\n                            : `top+=${this.rowsRect[loopIndex].y - lqdSection.rect.y} bottom`;\n                    this.setBgToEls.forEach((element) => {\n                        const onUpdate = () => {\n                            const i =\n                                this.direction < 1 && loopIndex > 0 ? loopIndex - 1 : loopIndex;\n                            this.options.interactWithHeader &&\n                                this.$stickyModules &&\n                                this._interactWithHeader(this.colors[i].luminosity);\n                        };\n                        timeline.fromTo(\n                            element,\n                            {\n                                backgroundColor:\n                                    loopIndex === 0\n                                        ? this.colors[loopIndex].color\n                                        : this.colors[loopIndex - 1].color,\n                            },\n                            {\n                                backgroundColor: this.colors[loopIndex].color,\n                                onUpdate,\n                                onComplete: () => {\n                                    element.style.transition = \"\";\n                                },\n                            },\n                            0,\n                        );\n                    });\n                    ScrollTrigger.create({\n                        animation: timeline,\n                        trigger: lqdSection.el,\n                        start,\n                        end: `+=${this.rowsRect[loopIndex].height}`,\n                        scrub: 0.1,\n                        onUpdate: (st) => {\n                            this.direction = st.direction;\n                        },\n                    });\n                }\n            }\n            $.fn[pluginName] = function (options) {\n                return this.each(function () {\n                    const pluginOptions = {\n                        ...$(this).data(\"liquid-bg-options\"),\n                        ...options,\n                    };\n                    if (!$.data(this, \"plugin_\" + pluginName)) {\n                        $.data(this, \"plugin_\" + pluginName, new Plugin(this, pluginOptions));\n                    }\n                });\n            };\n        })(jQuery);\n\n\n\n        // New code 18 oct\n        jQuery(function ($) {\n            const liquidBgEls = $(\"[data-liquid-bg]\").liquidBgColor();\n\n            if (liquidIsElementor) {\n                liquidBgEls.filter($liquidContents).each((_, el) => {\n                    if ($liquidMainHeader.length && !$liquidMainHeader.attr(\"data-liquid-bg\")) {\n                        $liquidMainHeader.liquidBgColor({\n                            manipulateColor: [\n                                { darken: 30 },\n                                { brighten: 15 },\n                                { saturate: 20 },\n                            ],\n                        });\n                    }\n                });\n            }\n        });\n\n    };\n}\n","!(function(win) {\n\n/**\n * FastDom\n *\n * Eliminates layout thrashing\n * by batching DOM read/write\n * interactions.\n *\n * @author Wilson Page <wilsonpage@me.com>\n * @author Kornel Lesinski <kornel.lesinski@ft.com>\n */\n\n'use strict';\n\n/**\n * Mini logger\n *\n * @return {Function}\n */\nvar debug = 0 ? console.log.bind(console, '[fastdom]') : function() {};\n\n/**\n * Normalized rAF\n *\n * @type {Function}\n */\nvar raf = win.requestAnimationFrame\n  || win.webkitRequestAnimationFrame\n  || win.mozRequestAnimationFrame\n  || win.msRequestAnimationFrame\n  || function(cb) { return setTimeout(cb, 16); };\n\n/**\n * Initialize a `FastDom`.\n *\n * @constructor\n */\nfunction FastDom() {\n  var self = this;\n  self.reads = [];\n  self.writes = [];\n  self.raf = raf.bind(win); // test hook\n  debug('initialized', self);\n}\n\nFastDom.prototype = {\n  constructor: FastDom,\n\n  /**\n   * We run this inside a try catch\n   * so that if any jobs error, we\n   * are able to recover and continue\n   * to flush the batch until it's empty.\n   *\n   * @param {Array} tasks\n   */\n  runTasks: function(tasks) {\n    debug('run tasks');\n    var task; while (task = tasks.shift()) task();\n  },\n\n  /**\n   * Adds a job to the read batch and\n   * schedules a new frame if need be.\n   *\n   * @param  {Function} fn\n   * @param  {Object} ctx the context to be bound to `fn` (optional).\n   * @public\n   */\n  measure: function(fn, ctx) {\n    debug('measure');\n    var task = !ctx ? fn : fn.bind(ctx);\n    this.reads.push(task);\n    scheduleFlush(this);\n    return task;\n  },\n\n  /**\n   * Adds a job to the\n   * write batch and schedules\n   * a new frame if need be.\n   *\n   * @param  {Function} fn\n   * @param  {Object} ctx the context to be bound to `fn` (optional).\n   * @public\n   */\n  mutate: function(fn, ctx) {\n    debug('mutate');\n    var task = !ctx ? fn : fn.bind(ctx);\n    this.writes.push(task);\n    scheduleFlush(this);\n    return task;\n  },\n\n  /**\n   * Clears a scheduled 'read' or 'write' task.\n   *\n   * @param {Object} task\n   * @return {Boolean} success\n   * @public\n   */\n  clear: function(task) {\n    debug('clear', task);\n    return remove(this.reads, task) || remove(this.writes, task);\n  },\n\n  /**\n   * Extend this FastDom with some\n   * custom functionality.\n   *\n   * Because fastdom must *always* be a\n   * singleton, we're actually extending\n   * the fastdom instance. This means tasks\n   * scheduled by an extension still enter\n   * fastdom's global task queue.\n   *\n   * The 'super' instance can be accessed\n   * from `this.fastdom`.\n   *\n   * @example\n   *\n   * var myFastdom = fastdom.extend({\n   *   initialize: function() {\n   *     // runs on creation\n   *   },\n   *\n   *   // override a method\n   *   measure: function(fn) {\n   *     // do extra stuff ...\n   *\n   *     // then call the original\n   *     return this.fastdom.measure(fn);\n   *   },\n   *\n   *   ...\n   * });\n   *\n   * @param  {Object} props  properties to mixin\n   * @return {FastDom}\n   */\n  extend: function(props) {\n    debug('extend', props);\n    if (typeof props != 'object') throw new Error('expected object');\n\n    var child = Object.create(this);\n    mixin(child, props);\n    child.fastdom = this;\n\n    // run optional creation hook\n    if (child.initialize) child.initialize();\n\n    return child;\n  },\n\n  // override this with a function\n  // to prevent Errors in console\n  // when tasks throw\n  catch: null\n};\n\n/**\n * Schedules a new read/write\n * batch if one isn't pending.\n *\n * @private\n */\nfunction scheduleFlush(fastdom) {\n  if (!fastdom.scheduled) {\n    fastdom.scheduled = true;\n    fastdom.raf(flush.bind(null, fastdom));\n    debug('flush scheduled');\n  }\n}\n\n/**\n * Runs queued `read` and `write` tasks.\n *\n * Errors are caught and thrown by default.\n * If a `.catch` function has been defined\n * it is called instead.\n *\n * @private\n */\nfunction flush(fastdom) {\n  debug('flush');\n\n  var writes = fastdom.writes;\n  var reads = fastdom.reads;\n  var error;\n\n  try {\n    debug('flushing reads', reads.length);\n    fastdom.runTasks(reads);\n    debug('flushing writes', writes.length);\n    fastdom.runTasks(writes);\n  } catch (e) { error = e; }\n\n  fastdom.scheduled = false;\n\n  // If the batch errored we may still have tasks queued\n  if (reads.length || writes.length) scheduleFlush(fastdom);\n\n  if (error) {\n    debug('task errored', error.message);\n    if (fastdom.catch) fastdom.catch(error);\n    else throw error;\n  }\n}\n\n/**\n * Remove an item from an Array.\n *\n * @param  {Array} array\n * @param  {*} item\n * @return {Boolean}\n */\nfunction remove(array, item) {\n  var index = array.indexOf(item);\n  return !!~index && !!array.splice(index, 1);\n}\n\n/**\n * Mixin own properties of source\n * object into the target.\n *\n * @param  {Object} target\n * @param  {Object} source\n */\nfunction mixin(target, source) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) target[key] = source[key];\n  }\n}\n\n// There should never be more than\n// one instance of `FastDom` in an app\nvar exports = win.fastdom = (win.fastdom || new FastDom()); // jshint ignore:line\n\n// Expose to CJS & AMD\nif ((typeof define) == 'function') define(function() { return exports; });\nelse if ((typeof module) == 'object') module.exports = exports;\n\n})( typeof window !== 'undefined' ? window : typeof this != 'undefined' ? this : globalThis);\n"],"names":[],"sourceRoot":""}